# 1.
![[Pasted image 20241222143541.png]]
![[Pasted image 20241222143606.png]]
![[Pasted image 20241222143639.png]]
![[Pasted image 20241222143721.png]]
![[Pasted image 20241222143830.png]]
問題となる問い合わせ文を表できる機能を目標に、機能リストを探してみると、利用者機能の”問い合わせ機能”（入力時）とサイト管理機能にある問い合わせ管理機能の2つしかないと確認できる。
問題文を確認すると、問い合わせ機能では、入力されたデータが適切にエンコードされて、表示されないことを確認できているので、この場合、同じ問い合わせデータを取り扱う機能として残っているのは問い合わせ管理機能のみで、答えは問い合わせ管理機能になる。

# 2.
![[Pasted image 20241222144241.png]]
![[Pasted image 20241222144305.png]]
![[Pasted image 20241222143830.png]]
![[Pasted image 20241222144551.png]]
まず、利用者情報取得できるのは、管理者IDでログインした後の機能と、機能表から確認できたので、手順としては、攻撃者がまず何らかの方法でシステムにログインすること（ログインする状態を入手すること）が最初になる。
前問のXSS脆弱性と組み合わせて、攻撃者は問い合わせに、ログインユーザーの~~セッションID~~Cookieを~~取得する~~攻撃者のサーバーに送付するコードを埋め込み、管理者がログインした後、問い合わせを表示するとログイン状態の~~セッションID~~Cookieが窃取され、攻撃者がその~~セッションID~~Cookieを使ってシステムにログインし、利用者の情報を取得する。
![[クロスサイトスクリプティング(XSS)#適切に保護されていないCookieを窃取するXSSサンプル]]

# 3.
![[Pasted image 20241222145422.png]]
![[Pasted image 20241222145550.png]]
![[Pasted image 20241222145626.png]]
![[Pasted image 20241222145639.png]]
図4のリクエストから見ると、サイトはCSRF Tokenを導入しており、そして表2の応答結果から見ても、CSRF_Tokenが未入力、またはCSRF Fieldが存在しない場合は、サーバではリクエストを受け付けしていない結果から、CSRF_Tokenの検証プロセスは設定されていることがわかる、それは質問文の”一定のCSRF対策ができている”を指しているもの、その上、表2の正常に処理したリクエストを見ると、他者のCSRF Tokenを使ってリクエスト送信しても受け付けられることから、CSRFの存在は確認されているものの、その正当性は確認されていないことがわかる。
なので手順は、~~攻撃者は攻撃対象のリクエストパケットを、自分が編集したいように改造し、そして自分のアカウントのCSRFトークンをリクエストに埋め込むことで、被害を与える。~~
攻撃者が自分のアカウントから取得したCSRF tokenと、改竄したいユーザー情報を埋め込んだ罠フォームを用意し、何らかの方法でログインしたユーザをそのフォームへのリンクを踏ませ、そこからユーザのセッションIDを取得しフォームに埋め込み、Xサイトにユーザー情報を変更するように送信する

# 4.
![[Pasted image 20241222150427.png]]
![[Pasted image 20241222150522.png]]
a,b: Cookie:Strictは同サイトの遷移にのみ、Cookieが送付されるので、a,bは❌
c: Cookie:Lax はトップレベルナビゲーションのGETリクエスト時のみ、Cookieが送付されるので、cは⭕️（トップレベルナビゲーションに限定されるが、ここの前提条件はログインした利用者のWebブラウザなので、トップレベルナビゲーションの繊維が想定される）
d: Cookie:Laxの場合はGET以外のリクエストにはCookieを送信しないので、❌
![[Pasted image 20241222152122.png]]
![[Cookie属性#SameSite属性]]

# 5.
![[Pasted image 20241222152342.png]]
![[Pasted image 20241222152402.png]]
![[Pasted image 20241222152419.png]]
![[Pasted image 20241222152516.png]]
注文管理番号は、注文年月の数字6けた（推測可能）、ランダムな英大文字6桁（推測はできないが、総当たりはできる）で構成されるので、攻撃者が注文番号を把握していなくても、固定した注文年月と、英大文字を総当たりすることで、攻撃することができる。

# 6.
![[Pasted image 20241222152906.png]]
![[Pasted image 20241222153056.png]]
説明2,3,4から、サーバの処理は注文管理コードをキーとして、その管理コードとセッション（ユーザー）間のの関係を検証していないことがわかる、そのため、追加すべき処理は、注文管理コードとセッションのユーザーと一致するかどうかを確認する処理

# 7.
![[Pasted image 20241222153329.png]]
![[Pasted image 20241222153355.png]]
![[Pasted image 20241222153431.png]]
CMSに関して最初の説明から、CMSのログインはPOSTのみ受付するとわかるので、テストに使用したGETリクエストは確かに改ざんすればCMSに画面まで辿り着けることはできるかもしれないが、SSRFで使用するリンクはあくまで攻撃者が改ざんすることはできるが、メソッドの変更者、接種した情報を使って新しいリクエストを偽造することはできないので、答えは、リクエストをPOSTメソッドに変更できないため(模範回答：変更後のURLにPOSTデータを送ることができないため)

# 8.
![[Pasted image 20241222154034.png]]
![[Pasted image 20241222154113.png]]
![[Pasted image 20241222154136.png]]
IMDSの説明から、サーバーから特定のURLにアクセスすると、クレデンシャル情報を入手できるとわかるので、答えは：リクエストの宛先URLをIMDSのクレデンシャル取得URLに改ざんした上、サーバーに送付する

# 9.
![[Pasted image 20241222154406.png]]
![[Pasted image 20241222154517.png]]
![[Pasted image 20241222154530.png]]
![[Pasted image 20241222154113.png]]
変更された方式2をまず確認し、トークンの取得は記載されたものの、特に認証処理に関しては言及されていないので、ということは単純のトークン取得の手順を増やして、そのトークンをリクエストに埋め込めば同じくクレデンシャル情報を取得できるから、回答は、トークン発行URLにPUTでアクセスしトークンを入手した後、そのトークン情報をリクエストのヘッダーに埋め込んだ後サーバに送信する
# 10.
![[Pasted image 20241222154803.png]]
![[Pasted image 20241222154822.png]]
![[Pasted image 20241222163206.png]]
![[Pasted image 20241222163243.png]]
サイトYはサイトPから情報を取得することが目的とするサイトで、発見された脆弱性も、サイトPへのアクセスしようとしたリクエストが改竄されていることから、このサイトPへ送付するリクエストのpageパラメーターを確認し、サイトPではなければ拒否するという対策が考えられる。