# 1.
![[Pasted image 20250209210743.png]]
![[Pasted image 20250209210819.png]]
![[Webシステムの三層構造#CDN]]
## キャッシュサーバ：
キャッシュサーバは、CDNの中、コンテンツのキャッシュバージョンを補完する分散型のサーバである。
キャッシュサーバは、アクセスしてきたユーザを分流し、ロードバランサーの役割を果たす一方、アクセスしてきたユーザの一番近い地理的位置からコンテンツを提供できる利点がある。
キャッシュサーバと呼ばれるのは、これらのサーバが保管するデータは、コンテンツの原本ではなく、キャッシュであるため、そのキャッシュを原本との一致性を保つため、TTLが設定されている。
また、キャッシュサーバでは動的キャッシュ(Dyanamic Cache)と静的キャッシュ(Static Cache)の違いがある、静的キャッシュは、その内容がユーザの入力等によって変化しないコンテンツ（ロゴや、固定の情報など）、ユーザの入力や、時間などの変量によって変化するコンテンツは動的キャッシュと呼ばれる。静的キャッシュが比較的に長めにTTL設定されているのに対して、動的キャッシュは短めにTTLが設定されており、そしてキャッシュサーバは基本のHTML構造や、部品をキャッシュし、変量を埋め込むような形でキャッシュすることがある。

# 2.
![[Pasted image 20250213200242.png]]
![[Pasted image 20250213200533.png]]
DDoS:
前問のキャッシュサーバの特徴にもあるように、キャッシュサーバはロードバランサーとしての効果もあるので、ロードバランサーが効果的に対処できる攻撃手法としては、大量のアクセスで宛先をサービス応答不能状態に追い込む、DDoS攻撃が考えられる。

# 3.
![[Pasted image 20250213215320.png]]
![[Pasted image 20250213215346.png]]
![[Pasted image 20250213215407.png]]
![[Pasted image 20250213215420.png]]
Host:
この問題を解説するには、まず問題のマルウェアの攻撃手法について知っておく必要がある。問題のマルウェアの攻撃手法は[[ドメインフロティング攻撃]]と呼ばれ、TLS接続時に提示したドメインと接続後送信するリクエストのドメインとの一致性が検証されないという脆弱性を利用して、悪意のあるサイトに接続してしまう攻撃を達成できている。
具体的な流れとしては、まずマルウェアが外部の悪意サイトに接続しようとして、TLSの接続を確立しようとする。この時点では[[TLS Handshake]]のClient HelloメッセージのExtensions-SNIへダーに、接続しようとするサイトのFQDNが記載されているが、Virtual Hostingや、問題のようにCDNに一回名前解決して接続するなどの場合では、一つの同じIPアドレスに複数の異なるURLが存在する。
そしてFWなどからみると、TLS接続の監視できる部分（TLS Helloで交わした暗号化されていないメッセージ）に記載されているFQDNが怪しいものではなく（むしろ場合によっては信頼できるFQDN)、この場合はFWが接続を許可する。
TLS接続確立後、実際マルウェアが送信するHTTP Requestのヘッダーの中では、本当に接続したい悪意サイトのFQDNが記載されている、そのFQDNを記載するヘッダーはHostになる。
現在ではCDNに、TLSのSNIとHostの不一致脆弱性を対策する方法があるが、適切に対策されていない場合では、クライアントとTLS接続を確立したCDNがクライアントからのリクエストを受け、リクエスト中のHostヘッダーにあるFQDNにパケットを転送してしまう。
# 4.
![[Pasted image 20250214123446.png]]
![[Pasted image 20250214123512.png]]
![[Pasted image 20250214123622.png]]
Y-CDN-U-FQDNの名前解決の結果と同じIPアドレスになるWebサイト：
まずは、問題の`Y-CDN-U-FQDN`について見ていく、このFQDNは問題中のY社がCDNにホストしているサイトに付与されたFQDNで、このFQDNを名前解決した結果では、クライアントに合わせて（地理的、コンテンツ適合上）適切なedgeサーバ（キャッシュサーバ）のIPアドレスが返される。
なので、この状況は複数のFQDNが同じIPアドレスを共有していると考えられるので、そのアドレスを封じ込んだ場合ではすべてこのアドレスを使用するFQDNに対してもアクセスできなくなる。

# 5.
![[Pasted image 20250215162039.png]]
![[Pasted image 20250215162142.png]]
~~TLS Client HelloメッセージのSNI値~~TLSの接続先サーバ名

# 6.
![[Pasted image 20250215162432.png]]
![[Pasted image 20250215162501.png]]
![[Pasted image 20250215162839.png]]
STは認証サーバに送付されないため:
図7の流れから見れば簡単にわかるが、STは認証サーバから生成された後そのまま送付され、認証サーバに戻ってこないので、検証しようがないのがその真偽を確かめない理由である。
ポイントはどうやってそれを回答する点にある、最初に考えた回答では、認証サーバがSTの発行だけ担当しているため、では明確にどうして検知できないという点について回答していなく、正解ではなく、次に'STが認証サーバに発行された後認証サーバに戻ってこないため'と考えたが、この回答は正解に近づいてきているが、若干長いのと、要点を掴めていない、認証サーバがSTを検証できないのは、処理3に入る状態のSTが認証サーバに送付されないだけで、それだけを回答する。

# 7.
![[Pasted image 20250215163134.png]]
![[Pasted image 20250215163214.png]]
STへの総当たりはオフラインで実施可能で、ログイン失敗は発生しないため：
STはサーバ管理者のパスワードのハッシュ値を鍵として暗号化したものなので、それに対する総当たり攻撃は、ローカルでSTを復号するトライを実施すれば達成できるため、サーバに繋げる必要はない。

# 8.
![[Pasted image 20250215164122.png]]
![[Pasted image 20250215164300.png]]
![[Pasted image 20250215164322.png]]
ウ:
![[SAML#SAML Request]]

# 9.
![[Pasted image 20250215165054.png]]
![[Pasted image 20250215165118.png]]
![[Pasted image 20250215164322.png]]
ア:
SAMLアサーションの署名を検証する処理に関する問題、認証に流れを見ると、SAML Responseを送信したのはIDaaSで、送信先はXPC経由でSaaSに送付されるので、署名者はIDaaSになる。

# 10.
![[Pasted image 20250215165536.png]]
![[Pasted image 20250215165118.png]]
不備・偽造
SAMLのでところを承認成功したら、次はそのSAML Assertionは本当のものかどうかを検証すべき、なので不備・偽造になる
# 11.
![[Pasted image 20250215171635.png]]
![[Pasted image 20250215171702.png]]
![[Pasted image 20250215164322.png]]
![[Pasted image 20250215172124.png]]
![[Pasted image 20250215172207.png]]
1,3,4

# 12.
![[Pasted image 20250215172428.png]]
![[Pasted image 20250215172447.png]]
![[Pasted image 20250215172704.png]]
![[Pasted image 20250215172804.png]]
SサービスがGrW-Gからスケジュール情報を取得する流れを描くフローチャートなので、ユーザがアクセスするのはまずSサービスになる、そしてSサービスがIDaaSにアクセスし、GrW-Gへのアクセス権を要求する、最後、IDaaSからアクセストークンを得たSサービスがGrW-Gにアクセスする。

# 13.
![[Pasted image 20250215173300.png]]
問題文に書いた通り、SサービスはGrWからスケジュール情報取得できるサービスで、前問でGrWへのアクセス許可を得たので、これからはスケジュール情報取得の流れに入る、各選択肢を見ると、まずア、とイは利用者から直接の取得要求で、利用者は認証されていないのでこれは許可されてないため不正解、次にSサービスから発生する2つの選択肢はウがIDaaSへの要求になるので不正解、正解はエ

# 14.
![[Pasted image 20250215173846.png]]
![[Pasted image 20250215173908.png]]
![[Pasted image 20250215174222.png]]
この攻撃の流れから見ると、中間人(MITM)が利用者の認可要求を改ざんし、自分のアカウントへの認可要求に変更する流れになるので、それを防ぐにはまずo:3にstateパラメータをつけて、p:4に戻ってきたstateパラメータと照合して改竄されているかどうかを検証する

# 15.
![[Pasted image 20250215175331.png]]
![[Pasted image 20250215175356.png]]
![[Pasted image 20250215175416.png]]
ウ