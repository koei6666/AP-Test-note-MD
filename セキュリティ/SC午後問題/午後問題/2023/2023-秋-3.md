---
tags:
  - TLS
  - Linux
  - WebAuthn
---

# 1.
![[Pasted image 20250113215059.png]]
![[Pasted image 20250113215155.png]]
コンテナのよる仮想化の脆弱性を悪用しなくても成功できる攻撃を選択とのことで、まずコンテナによる仮想化の脆弱性というのは、何らかの方法でコンテナ上のアプリにアクセスしているユーザが、アプリの環境から脱出し、コンテナのホストOSにアクセス出来るようになる。
[[コンテナエスケープ]]
![[Pasted image 20250113215619.png]]
選択項目を1つずつ見て、それぞれ間違った理由は：
　ア. CIデーモンはサーバのバックエンドに存在しているので、コンテナエスケープでホストOSに到着しなければそれにアクセスことはできないので、不正解。
　イ.バックエンドのプロセスに関わる行動なので、同じくコンテナ中からではわからない
　ウ.不正アクセスの試みは必ずしもコンテナ外から行う必要はないので、正解
　エ.上記と同じ理由で、コンテナの中からでも、命令取得できれば、それをコンテナの中で実行することができる。
　オ.他のNサービス利用者の痕跡が見えるのは、コンテナの中では不可能、コンテナエスケープした後に全仮想環境に向けて見ることはできる。
この問題では、要するに、選択肢の中から、コンテナから脱出しなくても（コンテナ中でも）利用される脆弱性を探すということ、コンテナは仮想化されたOS環境なので、普通のOS環境内に発生し得る悪意のコードの実行や、悪意のサイトへのアクセスは同じく発生するので、選択肢の中からこれらを選択する。

# 2.
![[Pasted image 20250113222410.png]]
ユーザが攻撃者の用意した偽サイトのリンクを踏んだ後、攻撃者が偽のログイン画面を表示し、ユーザのIDとパスワードを騙し取り、それを使ってログインを試みる、そして偽のTOTP入力画面を表示し、送信されたワンタイムパスワードを騙し取り、それを使ってログインする。

模範回答：偽サイトでワンタイムパスワードを騙し取り、有効期間内にそれを使ってログインする

# 3.
![[Pasted image 20250113223407.png]]
![[Pasted image 20250113223435.png]]
証明書発行ログはキーワードになる、証明書のログを確認することで認証局の信頼性と、コンプライアンスを確認するのはCertificate Transparency
![[Certificate Transparency]]
このような攻撃、ドメイン証明書ハイジャック攻撃と呼ばれ、以下の流れで実施される
![[証明書なりすまし攻撃　Domain Validation Hijacking]]
# 4.
![[Pasted image 20250113224438.png]]
![[Pasted image 20250113224714.png]]
脅威のないドメインを偽装として、TLSのホストを攻撃者のサーバに指定する手口なので、ドメインフロンティング攻撃
![[ドメインフロティング攻撃]]

# 5.
![[Pasted image 20250113230928.png]]
![[Pasted image 20250113231816.png]]
![[Pasted image 20250113231835.png]]
![[Pasted image 20250113231850.png]]
Linuxの環境変数に保存されているシークレットをどうやって盗み出すに関するの質問、環境変数の内容を確認するコマンドは`/proc`だが、それに導く証拠は以下になる：
まずシークレット機能に関して、説明文の中では、APIキーなどを利用者が登録し、ビルドスクリプトと分けて保管する機能とわかる、そしてそのシークレットを使うのはコマンド実行機能である。
次の説明を見ていくと、コマンド実行機能はバックエンドのCIデーモンが提供するとのことなので、コード実行に必要なシークレットも同じ環境に保管されると推測される。

>ここではシークレットが漏洩したと判断した重要な理由（コマンド実行機能が使われた）はTLS通信の内容には被害バックエンド上のソースコードが含まれていること、Nサービスの機能概要を見ると、コマンド実行機能はソースコード取得された後、repoのci.shのシェルスクリプトに記述された任意のコードが実行されると記載されているので、攻撃者は、バックエンのの`\proc`にアクセスするスクリプトをci.shに記載し、ソースコードを取得した後順次実行していったと考えられる。
>そして疑問に思っていた、どうしてシークレット機能を使ってそのままキーを確認しないかに関して（シークレット機能でキーを確認できるとは明記されていないが、設定できるということから変更などの場合もあるので、確認することはできると推測する）、バックエンドの説明には、linuxベースで、ソースコード実行機能とコマンド実行機能を提供していると明記しているに対して、シークレット機能を提供しているとは書いていないので、コマンド実行を通して
>shellスクリプトを実行するのほうが正解の確率が高い

バックエンドはLinuxので、その環境変数をチェックする`/proc`が正解になる。
![[Proc]]

# 6.
![[Pasted image 20250113233440.png]]
![[Pasted image 20250113233543.png]]
認証に用いる情報に含んだオリジンおよび署名をサーバが確認する仕組み
![[WebAuthn]] 

# 7.
![[Pasted image 20250113234204.png]]
![[Pasted image 20250113234233.png]]
![[DNS Records#^ec373f]]
![[PKI#^065014]]

# 8.
![[Pasted image 20250113234453.png]]
![[Pasted image 20250113234544.png]]
![[Pasted image 20250113234511.png]]
![[Pasted image 20250405154016.png]]
コードサイニング用証明書が漏洩されたため、攻撃者が悪意のコードを含んだ偽造のアプリを署名し、APIキーを使ってJストアにアップロードされる可能性がある

>Kさんが行った対応とは、コードサイニング用の証明書を無効にしたのと、STORE_API_KEYを削除する対応を行ったので、それに対応する被害は、攻撃者がそれらのキーを使って、悪意のあるコードをサイニングし、Storeにアップロードしたと考えられる

# 9.
![[Pasted image 20250113234836.png]]
![[Pasted image 20250113234907.png]]
![[Pasted image 20250113235015.png]]
漏洩した恐れのあるAPIキーをJ社WEBサイトから削除する

>一般的なAPI KEYは、デジタル署名のように有効無効が記録されているわけではないので、漏洩された場合ではAPI Providerから削除する対策が必要になる

# 10.
![[Pasted image 20250113235125.png]]
![[Pasted image 20250113235231.png]]
PCから取り出せないので、秘密鍵が漏洩しない

# 11.
![[Pasted image 20250113235343.png]]
![[Pasted image 20250113235401.png]]
![[Pasted image 20250113235515.png]]
影響：署名鍵を変更したため、アプリは起動しなくなる
対応：アプリをアップデートする