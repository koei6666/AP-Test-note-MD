# 1.
![[Pasted image 20250120224403.png]]
![[Pasted image 20250120224454.png]]
a = ⭕️ b = ❌ c = ❌
d = ⭕️ e = ⭕️ f = ❌
g = ⭕️ h = ⭕️ i = ⭕️
![[IaaS,PaaS,Saas]]

# 2.
![[Pasted image 20250120224823.png]]
![[Pasted image 20250120224852.png]]
![[Pasted image 20250120224943.png]]
![[Pasted image 20250120225031.png]]
仮想マシンサービスに対して：
性能監視ではサーバの一覧を参照する必要があるため、一覧の閲覧権限は必要
割り当てたファイルの閲覧する権限を必要とする業務はないので、閲覧権限は不要
仮想マシンの起動やファイル割り当て、ファイル削除編集などの権限を必要とする業務もないので、編集権限も不要

![[Pasted image 20250120225513.png]]
DBサービスに関連する業務はないので、権限は付与しない

![[Pasted image 20250120225608.png]]
性能監視では、各指標を監視する業務があるので、監視する性能指標一覧の閲覧が必要ので、一覧の閲覧権限が必要、そして、それぞれ性能指標の値を閲覧する必要があるので、閲覧権限も必要

ウ、エ、イ

# 3.
![[Pasted image 20250121194502.png]]
![[Pasted image 20250121194520.png]]
![[Pasted image 20250121194545.png]]
![[Pasted image 20250121194838.png]]
![[Pasted image 20250121194620.png]]
```json
{
"system" : "4000",
"account" : "11[1-9][0-9]",
"service" : "オブジェクトストレージサービス",
"event" : "オブジェクトの削除"
}
```

# 4.
![[Pasted image 20250121195544.png]]
![[Pasted image 20250121195657.png]]
![[Pasted image 20250121200538.png]]

m:アプリがサービスを要求するのは、そのアプリのサービスになるので、まずmは新日記サービス
n:Oauth承認になるので、外部サービスにアクセスするためには、まずそのサービスの認可サーバに接続し、リソースオーナーの認可を得ないといけないので、nはサービスT
o:アクセス先のサービスになるのでサービスTが正解
![[OAuth]]

# 5.
![[Pasted image 20250121200438.png]]
![[Pasted image 20250121200538.png]]
![[Pasted image 20250121200615.png]]
GETメソッドとエンドポイントが`/authorize`となっており、返信タイプを`code`と指定しているので認可要求のリクエストだとわかる、3が正解

POSTメソッドとエンドポイントが`/token`となっているので、コード要求フェーズだとわかる、このステップでは、認可フェーズで取得したcodeを引き換えに、アクセストークンを取得する

#Tricky #エンドポイント　GET/POSTメソッドの内容を確認する際に、エンドポイントを確認することが重要。エンドポイントはサーバ上特定のリクエストを受け付けるためのURLまたはURI、この問題の場合、GETのエンドポイントは`/authorize`ということは、サーバ上のauthorize,承認を担当するエンドポイントに送信するということ、逆に`/code`はコード発行する担当URIまで接続する


![[OAuthのパケット]]

# 6.
![[Pasted image 20250121230706.png]]
![[Pasted image 20250121230840.png]]
ウ、エ

# 7.
![[Pasted image 20250121231105.png]]
![[Pasted image 20250121231305.png]]
![[Pasted image 20250121231855.png]]
エンコード値GはクライアントIDとクライアントシークレットの連結文字列をbase64でエンコードした値、攻撃者がエンコード値Gを入手した場合ではPOSTメソッドのauthorizationのキーを構成することができる。
それに対策して、OAuthのパケットと、アクセストークン取得の流れでは、認可フローので取得した認可コードをパケットの`code`パラメーターに組み込む必要があるので、攻撃者はエンコード値Gだけ得て、codeパラメーターがなければアクセストークンを取得できない
アクセストークンの取得にあたって必要なcodeパラメーターを取得できないため

# 8.
![[Pasted image 20250121232241.png]]
![[Pasted image 20250121232303.png]]
検証コードのハッシュ値をbase64urlエンコードした値を認可サーバに保存されたチャレンジコードと照合し、検証する。
![[PKCE]]

# 9.
![[Pasted image 20250122000840.png]]
![[Pasted image 20250122001013.png]]
==OSSリポジトリのファイルZ過去の==変更履歴から==削除前のファイルを==取得する

# 10.
![[Pasted image 20250122001232.png]]
![[Pasted image 20250122001253.png]]
![[Pasted image 20250122001327.png]]
![[Pasted image 20250122000840.png]]
間違ってセンサティブ情報をアップロードしてしまったの対策として取るのだが、各開発者のアップロード権限を剥奪してはいけなく、その代わりにアップロードした内容を承認してからアップロードすれば間違った内容のアップロードを阻止できるので、開発リーダーにだけ承認権限を付与すれば問題の解決になる。

# 11.
![[Pasted image 20250122002022.png]]
![[Pasted image 20250122002051.png]]
![[Pasted image 20250122202916.png]]
不正プログラムが登録されないようにするため、そのトークンにアップロード権限を付与しなければ問題解決