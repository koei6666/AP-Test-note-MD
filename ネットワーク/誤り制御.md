
ネットワークを通じて転送したデータの誤りを検出したり、誤ったデータについてその場で回復処理を行うのが誤り制御である。
大きく分けて以下の二通りがある：
1. 誤り検出により再送を行う方法：パリティチェック、CRC
2. 誤り訂正により自己修復を行う方法：ハミング符号

### パリティチェック
データの中１ビットをパリティビットとして付加し、==誤りを検出する==。
パリティチェックは基本的に==誤り訂正の機能を持たない==ため、誤りが検出されたときには送信元に再送要求を行います。また、誤りが奇数個であれば検出できますが、==偶数個の誤りは検出できない==という特徴があります。（誤り訂正機能を持つのは、[[#ハミング符号（Hamming Code）]],[[#水平垂直パリティチェック]]がある)
例えば、7ビットのデータに１ビットのパリティビットを追加し、データの中の1が偶数になるようにパリティビットを追加する場合は偶数パリティといい、奇数にする場合は奇数パリティという。
パリティチェックは構造が簡単で、オーバーヘッドが少ないが、１ビットの誤りしか検出できない欠点がある。データが連続して誤り発生する場合（バースト誤り）には対応できない。

### CRC（Cyclic Redundancy Check）

CRCは、データのエラーチェックに広く用いられるアルゴリズムです。データの転送や保存時にその正確性を確認するために、特にネットワーク通信やファイルストレージなどで使用されます。

#### CRCの主要な機能
1. **エラーチェック**: CRCは、送信されたデータに含まれるエラーを検出する目的で使用されます。
2. **高い検出能力**: 複数のビットエラーでも検出できる場合が多く、高い信頼性があります。

#### CRCの動作の基本
1. **多項式の選択**: CRC計算の基礎となる多項式（通常は事前に決められたもの）を選びます。
2. **ビット操作**: 送信側はデータに対して特定のビット操作（多項式に基づく除算のようなもの）を行い、CRC値（通常は数ビット）を生成します。
3. **データの送信**: このCRC値を元のデータに付加して送信します。
4. **エラーチェック**: 受信側でも同じビット操作を行い、計算されたCRC値と送信されたCRC値が一致するかどうかを確認します。

**実世界の例**: Ethernetフレーム、Wi-Fiパケット、USB通信、ファイルフォーマット（例：ZIP、RARファイル）など、多くの技術でCRCが使用されています。

#### アルゴリズムの基本ステップ
1. **初期化**: CRCレジスタを0（または別の初期値）に設定します。
2. **ビットごとの処理**: 送信データの各ビットを上位ビットから処理していきます。
3. **CRC値の計算**: 特定の算術操作（XOR演算など）を用いてCRCレジスタの値を更新します。
4. **結果の取得**: 最終的なCRCレジスタの値がCRC値となります。

#### 一例としてのPythonコード
以下のPythonコードは、非常に単純なCRC-8（8ビットCRC）を計算します。

```python
def crc8(data):
    crc = 0  # Initialize CRC to 0
    for byte in data:
        crc ^= byte  # XOR byte into least significant byte of crc
        for _ in range(8):
            if crc & 0x80:  # If the highest bit is set
                crc = (crc << 1) ^ 0x07  # Polynomial 0x07
            else:
                crc <<= 1
            crc &= 0xFF  # Truncate to 8 bits
    return crc
```

このコードで、`crc8([0x31, 0x32, 0x33])`を呼び出すと、CRC値は`0x2E`となります。

#### セキュリティ
- **エラー検出のみ**: CRCはエラーを検出するだけであり、エラーを修正する機能はありません。
- **意図的な改ざん検出には不適**: CRCは偶発的なエラーを検出することを目的としており、セキュリティにおける意図的な改ざん検出には適していない場合が多いです。


### ハミング符号（Hamming Code）

ハミング符号は、エラー検出・訂正を行うための符号の一つです。データの送信や保存において、1ビットのエラーを検出し、更にそれを訂正（修復）する能力があります。

#### ハミング符号の特性
1. **エラー訂正能力**: 1ビットのエラーを訂正できる。
2. **エラー検出能力**: 複数ビットのエラーも検出は可能（但し、訂正はできない）。

#### ハミング符号の決め方

1. **データビットとパリティビット**: ハミング符号では、データビットと呼ばれる本来のメッセージに加えて、パリティビットと呼ばれるエラー検出・訂正用のビットが追加されます。

2. **パリティビットの位置**: パリティビットは通常、2のべき乗の位置（1, 2, 4, 8, ...）に挿入されます。

3. **パリティビットの計算**: 各パリティビットは特定のデータビットの組み合わせに対して計算され、その結果（0または1）が格納されます。

4. **エンコードとデコード**: 送信側では計算されたパリティビットを使用してデータをエンコードし、受信側ではそれを使用してエラーがあれば訂正します。

**実世界の例**: 通信システムやコンピュータメモリでよく使用されています。

#### 一例としてのアルゴリズム
1. **ビット数の確認**: 例えば、4ビットのデータを送信する場合、3つのパリティビットが必要です（`2^3 = 8`が`4（データビット）+ 3（パリティビット）+ 1（余裕）`を超えるため）。

2. **ビットの配置**: パリティビットは位置1, 2, 4に、データビットは位置3, 5, 6, 7に配置されます。

   ```
   p1 p2 d1 p3 d2 d3 d4
   ```

3. **パリティビットの計算**: 
    - `p1`は位置1, 3, 5, 7のビットに対するパリティ。
    - `p2`は位置2, 3, 6, 7のビットに対するパリティ。
    - `p3`は位置4, 5, 6, 7のビットに対するパリティ。

4. **エラー訂正**: 受信側でこれらのパリティビットを再計算し、不一致があれば該当するビットがエラーであると判断して訂正します。

#### Pythonコードの例
簡単なハミング符号(7,4)のエンコードを行うPythonコードの例です。

```python
def encode_hamming(data_bits):
    p1 = data_bits[0] ^ data_bits[1] ^ data_bits[3]
    p2 = data_bits[0] ^ data_bits[2] ^ data_bits[3]
    p3 = data_bits[1] ^ data_bits[2] ^ data_bits[3]
    return [p1, p2, data_bits[0], p3, data_bits[1], data_bits[2], data_bits[3]]
```

この関数で`encode_hamming([1, 0, 1, 1])`を呼び出すと、出力は`[0, 0, 1, 0, 0, 1, 1]`となります。

### 水平垂直パリティチェック
パリティチェックを水平方向と垂直方向で同時に行うことで、1ビットの誤りを訂正できる。
例：
送信
\[0,0]\[0]
\[0,0]\[0]
\[0,0,0]

受信：
\[0,0]\[0]
\[==1==,0]\[0]
\[0,0,0]

受信データのパリティビットが0になっているにも関わらず、受信したデータに1が入っているので、2行、1列のデータに間違いあることを発見できる。