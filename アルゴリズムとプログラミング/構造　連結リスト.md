#連結リスト (Linked list)
　　連結リストは要素をポインターで繋ぐデータ構造。
　　ポインターの配置によって三つのパターンがある。
　　　- 単方向リスト
　　　　ポインターは片方向にしか差してなく、各要素が次の要素を指す構造。
　　　- 双方向リスト
　　　　一つの要素には二つのポインタが備えて、各要素は前要素と次の要素を指す。
　　　- 循環リスト
　　　　各要素が次の要素を指し、末尾の要素は先頭の要素を指す。
　　連結リストの特徴は、各要素はメモリ上のアドレスが固定されてないので、配列のように要素番号を使って任意の要素をアクセスすることはできない。その一方、要素間はポインターで連結しているため、要素を編集するとき、追加や、削除が発生しても、ポインターの向け先だけを変更すれば済むので、追加や削除が頻繁に発生するデータに適している。
　　また、メモリ上の位置が固定されてないので、連結リストは使用するデータだけ動的に領域を確保している、無駄な領域は発生しない。

　　連結リストへの要素追加:
　　連結リストへの要素追加の計算量は、先頭と末尾、追加の計算量は同じ、先頭に追加する場合はhead nodeのリンクを追加される要素にリンクし,追加される要素を次の要素にリンク、逆のパターンも、途中の追加のパターンも、同じく2回のリンク変更は発生する。
　　(計算量が同じのは、only if the linked list structure have head and tail structure, for linked list without tail structure, there will be more complexity to travel down to last node of the list, same applies to add nodes in the middle, there are complexity happens travelling to the position you want to insert)

　要素の削除:
　要素の削除においては、末尾の削除は先頭の削除より計算量が多い、それは、連結リストにtail構造持っているかどうか関係なく発生する。
　先頭の要素を削除する場合は、headのリンクを次の要素に繋ぎに変更するだけ、末尾の要素を削除する場合は、削除する要素まで辿り、末尾前の要素のポインターを削除(null)にする。(tail構造がある場合tailとリンク)

　このようなデータ特性を活かして、FIFO(First in first out)の実現に必要なデータセットには、headとtail両方備えたlinked list( #キュー　#Queue),で追加は末尾から、取り出しは先頭からというO(n)のアクションができる。FIFOの必要がなく、追加と削除ともに先頭から行うというデータセット( #スタック　#Stack)にはtailの構造は不要。
