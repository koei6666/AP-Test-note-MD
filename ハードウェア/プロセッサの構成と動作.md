## プロセッサの構成と動作
　#プロセッサの構成
　　プロセッサは、制御装置、演算装置、レジスタ群で構成されている。
　　#制御装置　：主記憶に記憶されているプログラムの命令を読み出し、解読し、そのプログラムの命令によって各装置を制御する装置。
　　#演算装置　：制御装置の指示に従って算術演算、論理演算、比較などの処理を行う装置。
　　　　#ALU : Arithmetic and Logic Unit 算術論理演算装置
　　#レジスタ　：少量で高速な記憶装置。レジスタは又下の各種類がある。
　　　#プログラムカウンタ 　(PC):プログラムレジスタ、命令アドレスレジスタ、命令カウンタとも呼ばれる。次に読み出す命令の==格納アドレス==を持つ、命令が読み出されると自動的に＋１
　　　#命令レジスタ　(IR):主記憶から読み出した==命令==を記憶する。
　　　#汎用レジスタ (GR):データの一時的な保持や、計算結果の格納など、使い方を自由に決められる。
　　　#スタックポインタ　(SP):スタック領域の先頭アドレスを保持。[[構造　スタック]]
　　　#グローバルポインタ (GP):静的領域の先頭アドレスを格納する。
　　　#インデックスレジスタ :アドレス修飾に使われる。
　　　#ベースレジスタ :プログラムの先頭アドレスを保持。
　　　#アキュムレータ :条件付き分岐命令を実行するために，演算結果の状態を保持する。
　
　　[[過去問#^e1740f]]

　　### プログラムのロード
　　　CPUからプログラムを実行するには、まず主記憶上の領域を確保し、補助記憶装置からそこへプログラムを読み込む。
　　　主記憶上の格納場所や、プログラムのエントリーポイントなど実行するにあたって必要な情報をレジスタに格納した後、プログラムの実行を開始する。

　　#命令実行のステップ
　　　CPUは主記憶に読み込まれた命令を一つずつ実行していくが、一つの命令実行にあたり、以下の五つのステップがある。
　　　１.命令フェッチ（取り出し） ：
　　　　PCがIRに命令のアドレスを提示、実行する順番が来たらIRがPCの提示したアドレスから命令を取り出し、命令デコーダに渡して解読
　　　２.命令解読
　　　　命令デコーダが命令を解読した後、演算装置に命令実行の指示をする。
　　　３.オぺランドのアドレス計算
　　　　命令に含まれているオペランド（処理対象）のアドレスを計算
　　　４.オペランドの取得
　　　　計算されたアドレスからオペランドを取得し、汎用レジスタ　GRに格納
　　　５.実行

　　#ストアドプログラム方式
　　　主記憶に格納されたプログラムを順次呼び出し、CPUが実行する方式。ノイマン方式とも呼ばれる。
　　　この方式では、主記憶とCPU間のデータ転送能力がコンピュータ性能向上のボトルネックとなる。これをフォンノイマンボトルネックと呼ばれる。

　　## オペランドのアドレス計算
　　　#アドレス指定方式
　　　　プログラムの命令は、実際実施する命令を記載する命令部と、処理対象のアドレスを格納するアドレス部で構成されている（１アドレス方式）。
　　　　命令が解読されると、オペランドのアドレスが計算される。レジスタとアドレスでどのようにアドレスを計算するのかという指定をアドレス指定方式と呼ぶ。

　　　#直接アドレス指定 
　　　　アドレス指定方式の中一番単純なのは、直接アドレス指定。
　　　　命令のアドレス部に直接主記憶上の有効アドレスを記載する方式である。
　　　　問題点は、コンパイルの段階からアドレスを固定して指定しているため、記憶上の指定された領域を確保しなければいけない、指定領域が他のプログラムによって使用されている場合はそのプログラム終了するまで待機しなければいけない。
　　　　#再配置可能 のプログラムでは、ベースレジスタ番号との差分値を計算する #ベースアドレス指定方式　が使われている。

　　　以上２種類を含めて、主要アドレス指定方式は以下の通り。

| アドレス指定方式 | 例 | 説明 |
| --- | --- | --- |
| **直接アドレス指定方式** | MOV A, 32 | 指定されたアドレスから直接データを取得または保存します。絶対アドレス指定方式とも呼ばれる。 |
| **間接アドレス指定方式** | MOV A, [32] | 指定されたアドレス([32])を読み込み、そのアドレス([32])に格納されている即値のアドレスにアクセスする。 |
| **即値アドレス指定方式** | MOV A, #50 | 命令自体に含まれているデータを直接使用します。 |
| **ベースレジスタアドレス指定方式** | MOV A, 100(B) | ベースアドレス指定方式とも呼ばれる。ベースレジスタに格納されているアドレスに対するオフセットとして使用します。例の場合は、Bレジスタから100をオフセットし、取得した値をレジスタAに格納する流れを表している。計算式では：有効アドレス＝ベースレジスタ内容（ここではB)＋差分値(オフセット) |
| **インデックスレジスタアドレス指定方式** | MOV A, 100(X) | インデックスレジスタに格納されているアドレスに対するオフセットとして使用します。例では、基準値100に対してインデックスXのアドレスを探す流れを表しています |
| **相対アドレス指定方式** | MOV A, PC+10 | プログラムカウンタに格納されているアドレスに対するオフセットとして使用します。 |


#ビッグエディアン
#ビッグエンディアン 
#リトルエディアン
#リトルエンディアン 
　命令の処理対象は1バイト以上にある場合、複数のバイトを主記憶に読み込む順序を決める必要がある。
　==上==から読み込む場合は==ビッグエディアン==,==下==から読み込む場合は==リトルエディアン==と呼ばれる。

	　Data="1234" [00000001][00000010][00000011][00000101]=4byte
	　Big edian = 1 -> 2 -> 3 -> 4
	　little edian =4 -> 3 -> 2 -> 1

　読み込み順序は通常のプログラムではそれほど気にする必要はないが、読み込み順序の異なるシステム間の通信を担うネットワークプロトコルでは規定されているので、注意する必要がある。
　TCP/IPの規定したネットワークバイトオーダーでは、ビッグエディアンを使用しているので、異なるシステムのオーダーをビッグエディアンに変更する必要がある。

　#ウォッチドッグタイマ
　**ウォッチドッグタイマ**(Watchdog Timer)とは、システムに異常が発生したことを検知し、それを通知する目的で設定されるタイマです。ウォッチドッグには、英語で番犬という意味があります。  
  
　タイマには適切な時間がセットされていて、システムが正常なときは一定間隔でタイマの経過時間をリセットしています。しかし、システムに異常が起こるとリセットが行われなくなり、タイマのカウントが増加し続けることになります。  
　「設定した時間内にリセットが行われなかったのは、システムに異常が起きている」と考えられるので、ウォッチドッグタイマに設定された時間が経過した場合は_ノンマスカブル割込み_を発生させ、システムに異常を通知するという仕組みになっています。
　#タイマ割込み 
　システムの異常や暴走を検知する装置、最初設定した数値から一定時間間隔で減らし、タイマ値が０になるときに、 #ノンマスカブル割り込み が発生し、システムを強制的にリセットまたは中止する。
　システムが正常運転中です、ループするたびにタイマをリセットするのでタイマ値が０になることはなく、無限ループなどに落ちいた場合のみ割り込みが発生する。
