ページング方式では、下のような表（　#ページテーブル)を使って、仮想アドレスと物理アドレスの紐付けを行う、このような変換方式（**仮想アドレスを物理アドレスに変換する過程において、特定のテーブルまたは配列（インデックス）を使用する方式**)は[[ページング方式#^indexbased--|インデックス方式]]と呼ばれる。

ページング方式の流れは：
　　1. 主記憶上に必要なデータが存在しない状態が発生する（[[ページング方式#^daa8d2|ページフォールト]]）
　　2. FIFOやLRU[[ページング方式#^430696|アルゴリズム]]を用いて置換え対象のページを決定する
　　3. 置換え対象のページを主記憶から仮想記憶に退避させる（[[ページング方式#^69d6b8|ページアウト]]）
　　4. 実行に必要なページを仮想記憶から主記憶に移す（ページイン）
ページテーブルにはページ番号と、物理アドレスへの換算方法を記録している。
![[Pasted image 20230731232824.png]]
![[Pasted image 20230731233543.png]]

そして、ページテーブル上ではページフォールトビットが設けられ、主記憶上に存在しないページを1、存在するページを0とフラグ設定されている。
MMUは命令実行ごとにこのページテーブルを使って、主記憶上該当ページ存在するかどうかを判断し、仮想アドレスから物理アドレスを算出する。ページテーブルに頻繁にアクセスすると処理速度の低下につながるので、MMU内部にある、TLB(Translation Look-aside Buffer)（連想レジスタ）と呼ばれるキャッシュに最近参照したページの変換履歴を記憶し、MMUはそれを利用して変換を高速化している。

### ページフォールト

^daa8d2
プログラムの実行開始時には、全てのページが仮想記憶にマッピングされるため、どのページにも主記憶領域は割り当てられません。データ領域・コード領域にかかわらず、全てのページはページフォールトを契機に主記憶にロードされます。このためプログラムの開始時にはページフォールトが連続して発生することになります。

#ページフォールト は、ページング方式において要求されたページが主記憶上に存在しないときに発生する[[割り込み制御#^4697b3|内部割込み]]です（ページフォールトビットが1の時）。ページアウト／ページインの処理は、ページフォールトの発生を契機にして行われます。

### ページイン/ページアウト

^69d6b8

ページインは**デマンドページング**方式と、**プリページング**方式がある。
- **デマンドページング**
  ページフォールト（アクセス）が発生した際に、該当するページだけ主記憶に読み込む方式。
  主記憶に空きページの枠があればそこに読み込み、なければページを置き換えアリゴリズムで、不要ページを選定し、それを追い出してから読み込む。
  メモリ使用量を節約できる、プログラム開始時の主記憶へのロードによる遅延がない、ページの読込みが最小限で済むなどの利点があり、実際のOSでは基本的にこの方式が用いられている。
   ^4f7096
 - **プリページング**
   ページにアクセス要求がある前に、前もって参照されそうなページを主記憶に読み込んでおく方式。  
　アクセス要求があった時に周辺のページも同時に主記憶に読み込んだり、プログラムのロード時にたくさんのページを読み込んでおくことで、メモリ使用量は増加するがメモリアクセスの効率を向上させることができる効果はあるが、次に必要なページを予測するのが難しいため、実際ではデマンドページング方式と併用されている。

ページイン発生確率の計算例題
![[過去問#^1c4a37]]

### ページ置き換えアルゴリズム

^430696

- LRU : Least Recently Used
　LRUによるページングの例　: [[名詞解説・詳細説明#^211f6a]]
- LFU : Least Frequently Used

- FIFO
　LRUとFIFOともに、最初にページインしたページをこの時点から未来まで使われないと判断し、これらのページを優先的に置き換える考え方である。
　プログラムは基本的に順番に実行されるので、最も最初にページインしたページはこれから参照される可能性は低いという考え方に基づいている。
　ページング方式では基本的には、ページ数を増やすとページフォールト発生の確率が低くなるという考え方は間違いないだが、FIFO方式では置き換える順番の関係で、ページ数が増えるとかえってページフォールトが多発する[[ページング方式#^82389f|Beladyの例外]]という現象が発生する。

### インデックス変換方式
インデックス方式アドレス変換(Indexed Address Translation)は、アドレス変換の一種で、仮想アドレスを物理アドレスに変換する過程において、特定のテーブルまたは配列（インデックス）を使用する方式を指します。インデックスは通常、仮想アドレスから直接または間接的に派生されます。
例えば、仮想アドレスが `0x00002ABC` で、ページのサイズが 4KB の場合を考えてみましょう。ここで `0x00002` は仮想ページ番号（VPN: Virtual Page Number）であり、ページテーブルのインデックスとなります。`ABC`はページ内のオフセットです。仮想ページ番号 `0x00002` がページテーブルによって物理ページ番号 `0x00001` にマッピングされているとします。そうすると、最終的な物理アドレスは `0x00001ABC` になります。
なお、インデックス方式アドレス変換では、通常、メモリ管理ユニット（MMU: Memory Management Unit）がハードウェアレベルでアドレス変換を行います。
インデックス変換方式は小さなページテーブルをいくつか用いて使用中の仮想空間の領域だけをカバーし、本当に必要なときだけ追加のページテーブルを作成する多段ページテーブルを用いるので、必要最低限のページテーブルだけで済みます。
^indexbased--

### ページ大きさ最適化の影響
![[過去問#^d1485a]]

### 記憶保護
現在、ほぼすべてコンピュータアーキテクチャにおいて仮想記憶の方式として採用されているページング方式では、ページテーブルと呼ばれる表によって物理アドレスと仮想アドレスの対応を管理しています。ページテーブルの各エントリには対応する物理アドレスや主記憶上での存在を判別するためのフラグビット(ページフォールトビット)のほか、アクセス権の情報が設定されています。このアクセス権には、アクセス可能な権限レベルとアクセスの種類(読み・書き・実行)の組合せが記述されていて、MMU(Memory Management Unit：メモリ管理ユニット)がアドレス変換を行う度に妥当なアクセスであるかを判断しています。  
  
また同じくアクセスの妥当性を確認する仕組みとして「保護キー機構」があります。これは各プロセスに保護キーと呼ばれる数値を設定し、そのプロセスが使用中のページに同じ保護キーを設定することで記憶保護を図るものです。

### Beladyの例外
Belady's anomaly

Beladyの例外は、ページ置換アルゴリズムの中で、特にFIFO（First-In-First-Out）のアルゴリズムにおいて、ページフレーム数を増やすとページフォールトの回数が増えるという反直感的な現象を指します。

通常、ページフレームの数を増やせばページフォールトの回数が減ると考えられるのが普通ですが、Beladyの例外では、その逆の現象が起こります。

**例：**

以下のページ参照文字列と3つと4つのページフレームを持つシステムを考えます。

ページ参照文字列：1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5

**3つのページフレームの場合:**

- 初めの3ページ（1, 2, 3）はページフレームにロードされます。
- 次に4が来るので、1が置き換えられ、ページフォールトが発生します。
- 次に1が来るので、2が置き換えられ、ページフォールトが発生します。
- これを続けると、合計で9回のページフォールトが発生します。

**4つのページフレームの場合:**

- 初めの4ページ（1, 2, 3, 4）がロードされます。
- 次に1が来るので、既にロードされているので置き換えなし。
- 次に2が来るので、既にロードされているので置き換えなし。
- 次に5が来るので、1が置き換えられ、ページフォールトが発生します。
- これを続けると、合計で10回のページフォールトが発生します。

このように、ページフレーム数が増えたにもかかわらず、ページフォールトの回数が増加したのがBeladyの例外です。この現象はFIFOのように、ページの将来の利用情報を考慮しないアルゴリズムで起こります。最適ページ置換アルゴリズムなど、将来の情報を利用するアルゴリズムでは、この現象は発生しません。 ^82389f
