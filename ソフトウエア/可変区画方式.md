Variable Partitioning
プログラムの大きさに合わせて記憶を可変長のパーテションに区切って割り当てる方式。
この方式では、プログラムの大きさに合わせてパーティションを割り当てしているので、[[固定区画方式]]のような内部フラグメンションは起きない。

その一方区画の割り当てと解放を繰り返すと、アドレス間ではサイズの小さい未使用区画が発生する（異なるサイズのプログラムを割り当て、解放することを繰り返すと、そのプログラムサイズの差によって、そのような区画が発生する）。このような区画は、合算すれば十分な容量になるが、断続していてプログラムの割り当てはできないので、ガーベジとなる。
そしてこのような現象を外部フラグメンションと呼ばれる。

このような問題を解消するには、プログラムを連続したアドレスに移動し、空き区画をまとめる、メモリコンパクションという操作が行われる。メモリ中に実行中のプログラムを移動するして再配置することを #動的再配置 と呼ぶ

可変区画方式は記憶上のまとまった記憶領域（ホール:Whole)を分割して、各プログラムに割り当てするので、その割り当ては３種類のアルゴリズムがある：
　**1. 最初に合致（First Fit）**

　最初に見つかった十分に大きいホールにプロセスを割り当てます。これは最も単純で、検索時間が最も短い方式です。ただし、大きなホールを小さなプロセスに割り当てると、無駄なメモリ領域が残る可能性があります。

　**2. 最適に合致（Best Fit）**

　すべてのホールを検索し、プロセスのサイズに最も近いホールを選択します。これはメモリの使用効率を高める可能性がありますが、検索時間が長くなり、また小さなホールが多数生成されるという問題（外部断片化）が生じる可能性があります。

　**3. 最悪に合致（Worst Fit）**

　すべてのホールを検索し、最も大きいホールを選択します。これにより、後で大きなプロセスを割り当てるための空間が確保されますが、同様に検索時間が長くなり、また大きなホールが無駄になる可能性があります。

未使用領域（ホール）のアドレスとその大きさは、一般的にはデータ構造を用いて管理されます。最も一般的に使用されるデータ構造はLinked listですが、他のデータ構造（例えば、バランス木やヒープなど）も使用される場合があります。

**Linked listによる管理**

　Linked listを用いて未使用領域の情報を管理する場合、各ノードは未使用領域の開始アドレスとその大きさを保持します。リストはメモリアドレスによってソートされ、連続したホールは可能な限り結合されます。

　新しいプロセスがメモリを要求すると、リストは検索され、適切なホールが見つかるとその部分が割り当てられます。割り当てられたホールがプロセスに必要なサイズより大きい場合、そのホールは二つに分割され、一部が新しい未使用領域となります。プロセスが終了し、そのメモリが解放されると、その領域は未使用領域のリストに追加されます。

**他のデータ構造による管理**

　Linked listだけでなく、他のデータ構造も未使用領域の管理に使用されることがあります。例えば、バディシステムのようなメモリ管理システムでは、2分木が使用されます。また、未使用領域のサイズに基づいてデータを効率的に検索するために、バランス木や優先度付きキュー（ヒープ）を使用することもあります。


