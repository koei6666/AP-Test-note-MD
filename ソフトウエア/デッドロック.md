デッドロックとは、複数のプロセスやスレッドがお互いに他のプロセスが保持するリソースを待ってしまい、結果として全員が永遠に待ち続ける状態のことを指します。これは並行コンピューティングの問題であり、全体のシステム性能を大きく低下させる可能性があります。

==デッドロックの発生は、優先度の高低とは無関係です。==


> [!NOTE] デッドロックの発生の資源順番の関係
>資源占有順番が同じなプロセス感に関しては、デッドロックが発生しない。
> 資源を順番に引き当てるような順番だとデッドロックが発生する可能性がある。

^4e6802


デッドロックは、以下の4つの条件が同時に成り立つときに発生します。これらはコフマンの条件として知られています。

1. **相互排他（Mutual Exclusion）**: リソースは一度に一つのプロセスによってしか使用できない。 

2. **保持と待機（Hold and Wait）**: プロセスはすでに保持しているリソースを手放さずに、他のリソースが利用可能になるのを待つ。

3. **非剥奪（No Preemption）**: リソースはそのリソースを持っているプロセスが自発的にそれを解放するまで取り上げることができない。

4. **循環待機（Circular Wait）**: 2つ以上のプロセスが、それぞれが次にリクエストするリソースを保持している他のプロセスが形成するようなサイクルを形成している。

これらの条件がすべて満たされるとデッドロックが発生します。しかし、これらのうちの一つでも条件を満たさなければ、デッドロックは発生しないということも意味します。

例えば、銀行で2つの口座間の資金移動を行うプログラムを考えてみましょう。
プロセスAは口座1から口座2へ、プロセスBは口座2から口座1へ、お金を移動しようとします。
プロセスAが口座1のロックを取得し、その間にプロセスBが口座2のロックを取得しました。
次にプロセスAが口座2のロックを取得してから口座1のロックを解除し、プロセスBが口座1のロックを取得してから口座２のロックを解除しようとすると、お互いが待ち状態になってしまいます。この状態がデッドロックです。

このような問題を避けるためには、
　- #静的防止法:あらかじめ資源の割り当て方法を決めておく
　- #動的防止法:デッドロック発生しないよう、資源の割り当て状況に応じて動的な割り当てを行う
　- デッドロック発生した時点でそれを起こしたタスクを検出し、そのうち1つを強制的に終了させるなどの対処をする。

### デッドロックの検出方法
デッドロックの検出方法として、資源とタスクとの関係を有向グラフで表した資源グラフが使われる。
資源グラフでは、すべての要求を満足できるタスクに対して、そのタスクを起点または終点とするすべての辺を削除（簡約化）することで、資源グラフ内に存在するデッドロックの発生するタスクを発見することができる。
そして、データベースのようなトランザクション並行処理を表す待ちグラフでは、資源を表すノードがなく、各ノードはタスクと持ち資源両方を表している。
このようなグラフでも、要求が満足されるノードの辺を削除することで、グラフ内のデッドロック要因を発見することができる。
[[過去問#^dde37a]]
[[過去問#^d68535]]
