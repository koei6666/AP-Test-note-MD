### インデックス
インデックスを、条件が存在する列や、ORDER BY,GROUP BYが使用される列に付与することで処理速度の向上が期待できる。
ただし、以下のようなデータベースではインデックスの効果が反映されない：

### 1. **小規模なテーブル**
テーブルの行数が非常に少ない場合、インデックスの作成と維持のコストがクエリの実行時間の改善に見合わない場合があります。

### 2. **高いカーディナリティの列に対するビットマップインデックス**
ビットマップインデックスは低いカーディナリティの列で効果的ですが、高いカーディナリティ（多くのユニークな値）の列では非効率的になることがあります。

### 3. **書き込みが頻繁なデータベース**
書き込み（挿入、更新、削除）が非常に頻繁なデータベースでは、インデックスのメンテナンスがオーバーヘッドとなり、性能の低下を引き起こす場合があります。

### 4. **全列スキャンが一般的なクエリ**
特定の値や範囲の検索ではなく、全列のスキャンが主な操作である場合、インデックスはほとんどまたはまったく利用されない可能性があります。

### 5. **不適切に設計されたインデックス**
インデックスがクエリパターンやデータ分布と一致していない場合、インデックスの効果は期待できません。適切なインデックス設計と調整が不可欠です。

### 6. **非構造化データベース**
非構造化データ（JSON、XMLなど）を扱うデータベースでは、インデックスの利用が制限されるか、または特別なインデックス手法が必要になることがあります。

### 7. **メモリ内データベース**
一部のメモリ内データベースでは、データがメモリに完全に収まるため、インデックスなしで十分に高速にクエリを処理できる場合があります。

### インデックスの方式

### 1. **B-Tree インデックス**
**B+木**インデックスは、木の深さが一定で葉のみが値をもつ平衡木を用いたインデックスで、RDBMSのインデックス法として現在最も普及しています。
![[Pasted image 20231113231003.png]]
B+木は、根および節にはキー値の範囲と下層のブロックへのポインタ、葉にはキー値と表内の行の位置情報と前後の葉へのポインタが格納されていて、根から節をたどっていくことで目的のデータを検索します。すべてのキー値が同じ深さにあるので、データ量が増加してもパフォーマンスの低下が少なく、どのキー値に対してもランダム検索や範囲検索、挿入・更新・削除を効率よく行える特徴を持ちます。また葉に含まれている前後の葉へのポインタによって一致検索だけでなく、"<"，">"，"BETWEEN"などの範囲検索を効率よく行えます。しかしデータの分布に偏りがある場合や、_NULL値及び否定を含む検索条件では効果を発揮できません_。

- **バランスされた木構造**: 同じ深さの検索効率。
- **ソートされた順序**: 等価性と範囲クエリの効率化。
- **ログ構造の効率**: 変更の迅速な処理。
- **木の高さの最適化**: 大規模データセットの効率的な処理。
- **ディスク効率**: ディスクI/Oの最適化。

**例**: 人々の姓を保存するテーブルがある場合、姓に対してB-Treeインデックスを作成すると、特定の姓を持つ人々を素早く見つけることができます。

例題:
![[過去問#^ef2321]]

### 2. **ハッシュ インデックス**
ハッシュインデックスは、ハッシュ関数を使用して値をインデックス化します。これは、等価性のクエリに非常に効果的ですが、範囲クエリには効果的ではありません。
ハッシュ法なので、他のハッシュ法と同じく、複数の値が同じハッシュ値に差すことがある。

**例**: 商品IDで商品を検索するケースでは、ハッシュインデックスが高速に商品を取得できるため適用できます。

### 3. **ビットマップ インデックス**
ビットマップインデックスは、列の値が低いカーディナリティ（ユニークな値の数）を持つ場合に特に効果的です。

**例**: 性別や結婚状況など、2～3の異なる値しか持たない列に対して使用すると効率的です。
例えば、男性の場合は1、女性の場合は0など。

### 4. **空間インデックス**
地理空間データなどの空間的なクエリに最適化されたインデックスです。

**例**: 位置情報を持つデータに対して、特定の地域内のオブジェクトを素早く検索するために使用されます。

### 5. **複合インデックス**
複数の列にまたがるインデックスで、特定のクエリが複数の列を頻繁に使用する場合に便利です。

**例**: 顧客の姓と名を同時に検索するクエリが多い場合、これらの列の組み合わせに対して複合インデックスを作成すると効率的です。

### 6. **フルテキスト インデックス**
テキスト検索を最適化するためのインデックスで、大きなテキストフィールド内の単語を検索します。

**例**: 記事や製品の説明など、大きなテキストブロックを検索する必要がある場合に使用されます。

### **まとめ**
- **B-Tree**: 一般的なクエリに適用。
- **ハッシュ**: 等価性クエリに適用。
- **ビットマップ**: 低カーディナリティ列に適用。
- **空間**: 空間的クエリに適用。
- **複合**: 複数の列をまたがるクエリに適用。
- **フルテキスト**: テキスト検索に適用。

### オプティマイザ
オプティマイザはSQL文を実行する際に、問い合わせをどのように処理するのかを決めるクエリ最適機能である。
オプティマイザにはコストベース、とルールベースの2つパターンがある。

コストベースでは、ディスクファイルのIO回数や、入出力バッファ、ログバッファなどの使用状況といったRDBMSが収集した==統計情報==をもとに、表へのアクセスや表の結合にかかるIO,COUコストなどを見積もり、最適なアクセス方法並び結合順序や結合方法を選択する。

ルールベースでは、SQL文を解析し、その解析された情報と所定のルールによってアクセス方法を選択する。同じSQL文であれば同じアクセスパスとなり、たとえ順番に走査が高速な場合でも、インデックスが指定されていればインデックスを用いたアクセスパスを選択する。

[[データベースのチューニング]]
