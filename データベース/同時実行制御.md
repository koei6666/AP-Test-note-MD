複数のトランザクションが同時に実行しても、矛盾を起こすことなく処理を実行するメカニズムを同時実行制御という。
### ロック
ACIDの隔離性により、複数のトランザクションを並行実行する場合の結果は直列実行する場合の結果と同じでなければいけないが、同時実行制御が行われてない場合は、結果が異なる場合がある。

例えば以下の二つのトランザクションがあり、両方ともデータa=5に対して処理をする。
```
Transaction1:
	GET a
	a = a + 5
	GET a
```
```
Transaction2:
	GET a
	a = a + 10
```

二つのトランザクションを直列処理する場合は：
```
TR1:
	GET a => a=5
	a = a + 5 => a=10
	GET a => a=10
```
```
TR2:
	GET a => a=10
	a = a + 10 => a=20
	GET a => a=20
```
並列処理の場合では:
```
1.(1)GET a => a=5
2.(2)GET a => a=5
3.(1) a = a + 5 => a=10
4.(2) a = a + 10 => a=15
5.(1)GET a => a=15
```
並列処理の3と4ステップ目では、TR1のコミットした内容はTR1に上書きされ、変更消失したことがわかる(Lost update)。

このような問題を解決し、並行処理の場合では、データを順にアクセスし更新できるようにするには、ロックという手法を使って、アクセス中でコミットされてないデータをロックし、複数のトランザクションが同時にではなく、コミット完了次第順次にロックを解放しアクセスさせる。

### デッドロック
[[デッドロック]]

### ロック方式

#### 2相ロック方式
２相ロック方式はアクセス資源に一斉にロックをかけ、そして処理後一斉にロックを解除する方式である。
この方式では、直列可能性を保証できるが、デッドロック発生する可能性は残ってあります。

### 木規約
データに順番を付け、その順番でロックをかけてしていく方式である。
木規約は有向木で表現され、最初は木構造上任意のノッドにロックをかけて、次にロックかけできるのはそのノッドの子ノードのみ。
ロックの解除は任意のタイミングで解除でき、ロックかけた順番に従う必要はない。

木規約はデッドロックが発生しなく、直列可能性を保証できる方式だが、同時実効性が低くなるので、特殊な場合にしか使われない。

### ロックの種類
ロックは専有ロックと共有ロック２種類がある、専有ロックは、データ更新を行う場合、そのデータに対する他のトランザクションのアクセスを一切禁止するロック。
共有ロックは、同じデータに対して複数のトランザクションが参照のみのアクセスを許可する。

### ロックの粒度
ロックは表、ブロック、行という単位でかけられる、このロックの単位を粒度という、粒度が小さければ小さいほど同時実効性が高くなり、ロックの回数が多くなり、ロック処理へのオーバーヘッドが増大する。
一方、粒度が大きいほどトランザクションの管理は容易になるが、ロック解除の待ち時間が長くなり、同時実行性が低下する。

### 多版同時実行制御
MVCC(Multi-Version Concurrency Control)
通常では専有ロック中のデータに対して一つのトランザクションしかアクセスできないだが、たとえ後続のトランザクションがデータを参照だけしたい場合でも、データロックの解除を待つしかないだが、MVCCをすることで、アクセス中のデータに参照要求が発生する場合では、アクセス前(ロック前)のデータを返すことができ、同時実行性を高めることができる。

### その他の同時実行制御方式
以下の2つの同時実行制御方式では、ロックではないアルゴリズムで同時実行を制御するので、デッドロックは発生しない。

| 方式       | 内容                                                                                                                                                                                                                                                                                                                                                            |
| ---------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 時刻印方式 | トランザクション発生時の時刻印(Timestamp)Tとデータの最新時刻(Tr読み込み時刻、Tw書き込み時刻)と比較し、データアクセスの判断を行う。読み込みはTw<=T（データの更新がトランザクション発生以前に完了したもののみ読み込み、最新のデータを読み込むことを確保する),読み込み後はTrをTに設定、書き込み時はTr<=TかつTw<=Tである時のみ実施、実施後はTwをTに設定し更新する。 |
| 楽観的方式 | 同じデータには滅多に複数のトランザクションが同時にアクセスしないと考え処理を進め、書き込み直前に対象データは他のトランザクションにより更新されたかどうかを確認、更新されていればロールバックし、更新されてなければ書き込みする。                                                                                                                                |



